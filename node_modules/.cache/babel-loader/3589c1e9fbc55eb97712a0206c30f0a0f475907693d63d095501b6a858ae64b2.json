{"ast":null,"code":"// Packaging/modules magic dance.\n(function (factory) {\n  var L;\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['leaflet'], factory);\n  } else if (typeof module !== 'undefined') {\n    // Node/CommonJS\n    L = require('leaflet');\n    module.exports = factory(L);\n  } else {\n    // Browser globals\n    if (typeof window.L === 'undefined') throw 'Leaflet must be loaded first';\n    factory(window.L);\n  }\n})(function (L) {\n  \"use strict\";\n\n  L.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  };\n\n  /**\n   * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n   * @name L.GeometryUtil\n   */\n\n  L.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n         @tutorial distance-length\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function (map, latlngA, latlngB) {\n      return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function (map, latlng, latlngA, latlngB) {\n      var p = map.latLngToLayerPoint(latlng),\n        p1 = map.latLngToLayerPoint(latlngA),\n        p2 = map.latLngToLayerPoint(latlngB);\n      return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function (distance, unit) {\n      var isMetric = unit !== 'imperial',\n        distanceStr;\n      if (isMetric) {\n        // show metres when distance is < 1km, then show km\n        if (distance > 1000) {\n          distanceStr = (distance / 1000).toFixed(2) + ' km';\n        } else {\n          distanceStr = distance.toFixed(1) + ' m';\n        }\n      } else {\n        distance *= 1.09361;\n        if (distance > 1760) {\n          distanceStr = (distance / 1760).toFixed(2) + ' miles';\n        } else {\n          distanceStr = distance.toFixed(1) + ' yd';\n        }\n      }\n      return distanceStr;\n    },\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function (latlng, latlngA, latlngB, tolerance) {\n      tolerance = tolerance === undefined ? 0.2 : tolerance;\n      var hypotenuse = latlngA.distanceTo(latlngB),\n        delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n      return delta / hypotenuse < tolerance;\n    },\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function (coords) {\n      var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n      return accumulated.length > 0 ? accumulated[accumulated.length - 1] : 0;\n    },\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function (coords) {\n      if (typeof coords.getLatLngs == 'function') {\n        coords = coords.getLatLngs();\n      }\n      if (coords.length === 0) return [];\n      var total = 0,\n        lengths = [0];\n      for (var i = 0, n = coords.length - 1; i < n; i++) {\n        total += coords[i].distanceTo(coords[i + 1]);\n        lengths.push(total);\n      }\n      return lengths;\n    },\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function (map, latlng, latlngA, latlngB) {\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var p = map.project(latlng, maxzoom),\n        p1 = map.project(latlngA, maxzoom),\n        p2 = map.project(latlngB, maxzoom),\n        closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n      return map.unproject(closest, maxzoom);\n    },\n    /**\n        Returns the closest latlng on layer.\n         Accept nested arrays\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function (map, layer, latlng, vertices) {\n      var latlngs,\n        mindist = Infinity,\n        result = null,\n        i,\n        n,\n        distance,\n        subResult;\n      if (layer instanceof Array) {\n        // if layer is Array<Array<T>>\n        if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n          // if we have nested arrays, we calc the closest for each array\n          // recursive\n          for (i = 0; i < layer.length; i++) {\n            subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n            if (subResult && subResult.distance < mindist) {\n              mindist = subResult.distance;\n              result = subResult;\n            }\n          }\n          return result;\n        } else if (layer[0] instanceof L.LatLng || typeof layer[0][0] === 'number' || typeof layer[0].lat === 'number') {\n          // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n          layer = L.polyline(layer);\n        } else {\n          return result;\n        }\n      }\n\n      // if we don't have here a Polyline, that means layer is incorrect\n      // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n      if (!(layer instanceof L.Polyline)) return result;\n\n      // deep copy of latlngs\n      latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n      // add the last segment for L.Polygon\n      if (layer instanceof L.Polygon) {\n        // add the last segment for each child that is a nested array\n        var addLastSegment = function (latlngs) {\n          if (L.Polyline._flat(latlngs)) {\n            latlngs.push(latlngs[0]);\n          } else {\n            for (var i = 0; i < latlngs.length; i++) {\n              addLastSegment(latlngs[i]);\n            }\n          }\n        };\n        addLastSegment(latlngs);\n      }\n\n      // we have a multi polygon / multi polyline / polygon with holes\n      // use recursive to explore and return the good result\n      if (!L.Polyline._flat(latlngs)) {\n        for (i = 0; i < latlngs.length; i++) {\n          // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n          subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n          if (subResult.distance < mindist) {\n            mindist = subResult.distance;\n            result = subResult;\n          }\n        }\n        return result;\n      } else {\n        // Lookup vertices\n        if (vertices) {\n          for (i = 0, n = latlngs.length; i < n; i++) {\n            var ll = latlngs[i];\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n            if (distance < mindist) {\n              mindist = distance;\n              result = ll;\n              result.distance = distance;\n            }\n          }\n          return result;\n        }\n\n        // Keep the closest point of all segments\n        for (i = 0, n = latlngs.length; i < n - 1; i++) {\n          var latlngA = latlngs[i],\n            latlngB = latlngs[i + 1];\n          distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n          if (distance <= mindist) {\n            mindist = distance;\n            result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n            result.distance = distance;\n          }\n        }\n        return result;\n      }\n    },\n    /**\n        Returns the closest layer to latlng among a list of layers.\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function (map, layers, latlng) {\n      var mindist = Infinity,\n        result = null,\n        ll = null,\n        distance = Infinity;\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n        if (layer instanceof L.LayerGroup) {\n          // recursive\n          var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n          if (subResult.distance < mindist) {\n            mindist = subResult.distance;\n            result = subResult;\n          }\n        } else {\n          // Single dimension, snap on points, else snap on closest\n          if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n          } else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance; // Can return null if layer has no points.\n          }\n\n          if (distance < mindist) {\n            mindist = distance;\n            result = {\n              layer: layer,\n              latlng: ll,\n              distance: distance\n            };\n          }\n        }\n      }\n      return result;\n    },\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n         @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function (map, layers, latlng, n) {\n      n = typeof n === 'number' ? n : layers.length;\n      if (n < 1 || layers.length < 1) {\n        return null;\n      }\n      var results = [];\n      var distance, ll;\n      for (var i = 0, m = layers.length; i < m; i++) {\n        var layer = layers[i];\n        if (layer instanceof L.LayerGroup) {\n          // recursive\n          var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n          results.push(subResult);\n        } else {\n          // Single dimension, snap on points, else snap on closest\n          if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n          } else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance; // Can return null if layer has no points.\n          }\n\n          results.push({\n            layer: layer,\n            latlng: ll,\n            distance: distance\n          });\n        }\n      }\n      results.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n      if (results.length > n) {\n        return results.slice(0, n);\n      } else {\n        return results;\n      }\n    },\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function (map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n      var results = [];\n      var ll = null;\n      var distance = 0;\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n        if (typeof layer.getLatLng == 'function') {\n          ll = layer.getLatLng();\n          distance = L.GeometryUtil.distance(map, latlng, ll);\n        } else {\n          ll = L.GeometryUtil.closest(map, layer, latlng);\n          if (ll) distance = ll.distance; // Can return null if layer has no points.\n        }\n\n        if (ll && distance < radius) {\n          results.push({\n            layer: layer,\n            latlng: ll,\n            distance: distance\n          });\n        }\n      }\n      var sortedResults = results.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n      return sortedResults;\n    },\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n      tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n      withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n      var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n      if (!result || result.distance > tolerance) return null;\n\n      // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n      if (withVertices && typeof result.layer.getLatLngs == 'function') {\n        var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n        if (closest.distance < tolerance) {\n          result.latlng = closest;\n          result.distance = L.GeometryUtil.distance(map, closest, latlng);\n        }\n      }\n      return result;\n    },\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function (pA, pB, ratio) {\n      return L.point(pA.x * (1 - ratio) + ratio * pB.x, pA.y * (1 - ratio) + ratio * pB.y);\n    },\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function (map, latLngs, ratio) {\n      latLngs = latLngs instanceof L.Polyline ? latLngs.getLatLngs() : latLngs;\n      var n = latLngs.length;\n      if (n < 2) {\n        return null;\n      }\n\n      // ensure the ratio is between 0 and 1;\n      ratio = Math.max(Math.min(ratio, 1), 0);\n      if (ratio === 0) {\n        return {\n          latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n          predecessor: -1\n        };\n      }\n      if (ratio == 1) {\n        return {\n          latLng: latLngs[latLngs.length - 1] instanceof L.LatLng ? latLngs[latLngs.length - 1] : L.latLng(latLngs[latLngs.length - 1]),\n          predecessor: latLngs.length - 2\n        };\n      }\n\n      // project the LatLngs as Points,\n      // and compute total planar length of the line at max precision\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var pts = [];\n      var lineLength = 0;\n      for (var i = 0; i < n; i++) {\n        pts[i] = map.project(latLngs[i], maxzoom);\n        if (i > 0) lineLength += pts[i - 1].distanceTo(pts[i]);\n      }\n      var ratioDist = lineLength * ratio;\n\n      // follow the line segments [ab], adding lengths,\n      // until we find the segment where the points should lie on\n      var cumulativeDistanceToA = 0,\n        cumulativeDistanceToB = 0;\n      for (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n        var pointA = pts[i],\n          pointB = pts[i + 1];\n        cumulativeDistanceToA = cumulativeDistanceToB;\n        cumulativeDistanceToB += pointA.distanceTo(pointB);\n      }\n      if (pointA == undefined && pointB == undefined) {\n        // Happens when line has no length\n        var pointA = pts[0],\n          pointB = pts[1],\n          i = 1;\n      }\n\n      // compute the ratio relative to the segment [ab]\n      var segmentRatio = cumulativeDistanceToB - cumulativeDistanceToA !== 0 ? (ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA) : 0;\n      var interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n      return {\n        latLng: map.unproject(interpolatedPoint, maxzoom),\n        predecessor: i - 1\n      };\n    },\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function (map, polyline, latlng) {\n      var latlngs = polyline.getLatLngs();\n      if (latlng.equals(latlngs[0])) return 0.0;\n      if (latlng.equals(latlngs[latlngs.length - 1])) return 1.0;\n      var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n        lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n        total_length = lengths[lengths.length - 1],\n        portion = 0,\n        found = false;\n      for (var i = 0, n = latlngs.length - 1; i < n; i++) {\n        var l1 = latlngs[i],\n          l2 = latlngs[i + 1];\n        portion = lengths[i];\n        if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n          portion += l1.distanceTo(point);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n      }\n      return portion / total_length;\n    },\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function (polyline) {\n      return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function (map, polyline, start, end) {\n      if (start > end) {\n        return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0 - start, 1.0 - end);\n      }\n\n      // Bound start and end to [0-1]\n      start = Math.max(Math.min(start, 1), 0);\n      end = Math.max(Math.min(end, 1), 0);\n      var latlngs = polyline.getLatLngs(),\n        startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n        endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n      // Return single point if start == end\n      if (start == end) {\n        var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        return [point.latLng];\n      }\n      // Array.slice() works indexes at 0\n      if (startpoint.predecessor == -1) startpoint.predecessor = 0;\n      if (endpoint.predecessor == -1) endpoint.predecessor = 0;\n      var result = latlngs.slice(startpoint.predecessor + 1, endpoint.predecessor + 1);\n      result.unshift(startpoint.latLng);\n      result.push(endpoint.latLng);\n      return result;\n    },\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function (polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n        llb = other.getLatLngs();\n      return lla[lla.length - 1].equals(llb[0]);\n    },\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function (polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n        llb = other.getLatLngs();\n      return lla[0].equals(llb[llb.length - 1]);\n    },\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function (polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n        llb = other.getLatLngs(),\n        start = lla[0];\n      return start.equals(llb[0]) || start.equals(llb[llb.length - 1]);\n    },\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function (a, b) {\n      return Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI;\n    },\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function (a, b) {\n      var s = (b.y - a.y) / (b.x - a.x),\n        o = a.y - s * a.x;\n      return {\n        'a': s,\n        'b': o\n      };\n    },\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function (map, latlngPoint, angleDeg, latlngCenter) {\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var angleRad = angleDeg * Math.PI / 180,\n        pPoint = map.project(latlngPoint, maxzoom),\n        pCenter = map.project(latlngCenter, maxzoom),\n        x2 = Math.cos(angleRad) * (pPoint.x - pCenter.x) - Math.sin(angleRad) * (pPoint.y - pCenter.y) + pCenter.x,\n        y2 = Math.sin(angleRad) * (pPoint.x - pCenter.x) + Math.cos(angleRad) * (pPoint.y - pCenter.y) + pCenter.y;\n      return map.unproject(new L.Point(x2, y2), maxzoom);\n    },\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        lon1 = latlng1.lng * rad,\n        lon2 = latlng2.lng * rad,\n        y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n        x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n      var bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;\n      return bearing >= 180 ? bearing - 360 : bearing;\n    },\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function (latlng, heading, distance) {\n      heading = (heading + 360) % 360;\n      var rad = Math.PI / 180,\n        radInv = 180 / Math.PI,\n        R = L.CRS.Earth.R,\n        // approximation of Earth's radius\n        lon1 = latlng.lng * rad,\n        lat1 = latlng.lat * rad,\n        rheading = heading * rad,\n        sinLat1 = Math.sin(lat1),\n        cosLat1 = Math.cos(lat1),\n        cosDistR = Math.cos(distance / R),\n        sinDistR = Math.sin(distance / R),\n        lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 * sinDistR * Math.cos(rheading)),\n        lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR * cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n      lon2 = lon2 * radInv;\n      lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n      return L.latLng([lat2 * radInv, lon2]);\n    },\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function (map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n        pointB = map.latLngToContainerPoint(latlngB),\n        angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function (map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n        latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    }\n  });\n  return L.GeometryUtil;\n});","map":{"version":3,"names":["factory","L","define","amd","module","require","exports","window","Polyline","_flat","LineUtil","isFlat","latlngs","Util","isArray","GeometryUtil","extend","distance","map","latlngA","latlngB","latLngToLayerPoint","distanceTo","distanceSegment","latlng","p","p1","p2","pointToSegmentDistance","readableDistance","unit","isMetric","distanceStr","toFixed","belongsSegment","tolerance","undefined","hypotenuse","delta","length","coords","accumulated","accumulatedLengths","getLatLngs","total","lengths","i","n","push","closestOnSegment","maxzoom","getMaxZoom","Infinity","getZoom","project","closest","closestPointOnSegment","unproject","layer","vertices","mindist","result","subResult","Array","LatLng","lat","polyline","JSON","parse","stringify","slice","Polygon","addLastSegment","ll","closestLayer","layers","LayerGroup","getLayers","getLatLng","nClosestLayers","results","m","sort","a","b","layersWithin","radius","sortedResults","closestLayerSnap","withVertices","interpolateOnPointSegment","pA","pB","ratio","point","x","y","interpolateOnLine","latLngs","Math","max","min","latLng","predecessor","pts","lineLength","ratioDist","cumulativeDistanceToA","cumulativeDistanceToB","pointA","pointB","segmentRatio","interpolatedPoint","locateOnLine","equals","total_length","portion","found","l1","l2","toString","reverse","extract","start","end","startpoint","endpoint","unshift","isBefore","other","lla","llb","isAfter","startsAtExtremity","computeAngle","atan2","PI","computeSlope","s","o","rotatePoint","latlngPoint","angleDeg","latlngCenter","angleRad","pPoint","pCenter","x2","cos","sin","y2","Point","bearing","latlng1","latlng2","rad","lat1","lat2","lon1","lng","lon2","destination","heading","radInv","R","CRS","Earth","rheading","sinLat1","cosLat1","cosDistR","sinDistR","asin","angle","latLngToContainerPoint","destinationOnSegment"],"sources":["C:/vscode/logistik-company/node_modules/leaflet-geometryutil/src/leaflet.geometryutil.js"],"sourcesContent":["// Packaging/modules magic dance.\n(function (factory) {\n    var L;\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['leaflet'], factory);\n    } else if (typeof module !== 'undefined') {\n        // Node/CommonJS\n        L = require('leaflet');\n        module.exports = factory(L);\n    } else {\n        // Browser globals\n        if (typeof window.L === 'undefined')\n            throw 'Leaflet must be loaded first';\n        factory(window.L);\n    }\n}(function (L) {\n\"use strict\";\n\nL.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n/**\n * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n * @name L.GeometryUtil\n */\n\nL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n\n        @tutorial distance-length\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function (map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function (map, latlng, latlngA, latlngB) {\n        var p = map.latLngToLayerPoint(latlng),\n           p1 = map.latLngToLayerPoint(latlngA),\n           p2 = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function (distance, unit) {\n        var isMetric = (unit !== 'imperial'),\n            distanceStr;\n        if (isMetric) {\n            // show metres when distance is < 1km, then show km\n            if (distance > 1000) {\n                distanceStr = (distance  / 1000).toFixed(2) + ' km';\n            }\n            else {\n                distanceStr = distance.toFixed(1) + ' m';\n            }\n        }\n        else {\n            distance *= 1.09361;\n            if (distance > 1760) {\n                distanceStr = (distance / 1760).toFixed(2) + ' miles';\n            }\n            else {\n                distanceStr = distance.toFixed(1) + ' yd';\n            }\n        }\n        return distanceStr;\n    },\n\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function(latlng, latlngA, latlngB, tolerance) {\n        tolerance = tolerance === undefined ? 0.2 : tolerance;\n        var hypotenuse = latlngA.distanceTo(latlngB),\n            delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n        return delta/hypotenuse < tolerance;\n    },\n\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function (coords) {\n        var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n        return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;\n    },\n\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function (coords) {\n        if (typeof coords.getLatLngs == 'function') {\n            coords = coords.getLatLngs();\n        }\n        if (coords.length === 0)\n            return [];\n        var total = 0,\n            lengths = [0];\n        for (var i = 0, n = coords.length - 1; i< n; i++) {\n            total += coords[i].distanceTo(coords[i+1]);\n            lengths.push(total);\n        }\n        return lengths;\n    },\n\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function (map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var p = map.project(latlng, maxzoom),\n           p1 = map.project(latlngA, maxzoom),\n           p2 = map.project(latlngB, maxzoom),\n           closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n        return map.unproject(closest, maxzoom);\n    },\n\n    /**\n        Returns the closest latlng on layer.\n\n        Accept nested arrays\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function (map, layer, latlng, vertices) {\n\n        var latlngs,\n            mindist = Infinity,\n            result = null,\n            i, n, distance, subResult;\n\n        if (layer instanceof Array) {\n            // if layer is Array<Array<T>>\n            if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n                // if we have nested arrays, we calc the closest for each array\n                // recursive\n                for (i = 0; i < layer.length; i++) {\n                    subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n                    if (subResult && subResult.distance < mindist) {\n                        mindist = subResult.distance;\n                        result = subResult;\n                    }\n                }\n                return result;\n            } else if (layer[0] instanceof L.LatLng\n                        || typeof layer[0][0] === 'number'\n                        || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n                layer = L.polyline(layer);\n            } else {\n                return result;\n            }\n        }\n\n        // if we don't have here a Polyline, that means layer is incorrect\n        // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n        if (! ( layer instanceof L.Polyline ) )\n            return result;\n\n        // deep copy of latlngs\n        latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n        // add the last segment for L.Polygon\n        if (layer instanceof L.Polygon) {\n            // add the last segment for each child that is a nested array\n            var addLastSegment = function(latlngs) {\n                if (L.Polyline._flat(latlngs)) {\n                    latlngs.push(latlngs[0]);\n                } else {\n                    for (var i = 0; i < latlngs.length; i++) {\n                        addLastSegment(latlngs[i]);\n                    }\n                }\n            };\n            addLastSegment(latlngs);\n        }\n\n        // we have a multi polygon / multi polyline / polygon with holes\n        // use recursive to explore and return the good result\n        if ( ! L.Polyline._flat(latlngs) ) {\n            for (i = 0; i < latlngs.length; i++) {\n                // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n                subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            }\n            return result;\n\n        } else {\n\n            // Lookup vertices\n            if (vertices) {\n                for(i = 0, n = latlngs.length; i < n; i++) {\n                    var ll = latlngs[i];\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                    if (distance < mindist) {\n                        mindist = distance;\n                        result = ll;\n                        result.distance = distance;\n                    }\n                }\n                return result;\n            }\n\n            // Keep the closest point of all segments\n            for (i = 0, n = latlngs.length; i < n-1; i++) {\n                var latlngA = latlngs[i],\n                    latlngB = latlngs[i+1];\n                distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n                if (distance <= mindist) {\n                    mindist = distance;\n                    result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n                    result.distance = distance;\n                }\n            }\n            return result;\n        }\n\n    },\n\n    /**\n        Returns the closest layer to latlng among a list of layers.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function (map, layers, latlng) {\n        var mindist = Infinity,\n            result = null,\n            ll = null,\n            distance = Infinity;\n\n        for (var i = 0, n = layers.length; i < n; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            } else {\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                if (distance < mindist) {\n                    mindist = distance;\n                    result = {layer: layer, latlng: ll, distance: distance};\n                }\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n\n        @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function (map, layers, latlng, n) {\n        n = typeof n === 'number' ? n : layers.length;\n\n        if (n < 1 || layers.length < 1) {\n            return null;\n        }\n\n        var results = [];\n        var distance, ll;\n\n        for (var i = 0, m = layers.length; i < m; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                results.push(subResult);\n            } else {\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                results.push({layer: layer, latlng: ll, distance: distance});\n            }\n        }\n\n        results.sort(function(a, b) {\n            return a.distance - b.distance;\n        });\n\n        if (results.length > n) {\n            return results.slice(0, n);\n        } else  {\n            return results;\n        }\n    },\n\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function(map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n\n      var results = [];\n      var ll = null;\n      var distance = 0;\n\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n        }\n        else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance;  // Can return null if layer has no points.\n        }\n\n        if (ll && distance < radius) {\n            results.push({layer: layer, latlng: ll, distance: distance});\n        }\n      }\n\n      var sortedResults = results.sort(function(a, b) {\n          return a.distance - b.distance;\n      });\n\n      return sortedResults;\n    },\n\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n        tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n        withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n\n        var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n        if (!result || result.distance > tolerance)\n            return null;\n\n        // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n        if (withVertices && typeof result.layer.getLatLngs == 'function') {\n            var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n            if (closest.distance < tolerance) {\n                result.latlng = closest;\n                result.distance = L.GeometryUtil.distance(map, closest, latlng);\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function (pA, pB, ratio) {\n        return L.point(\n            (pA.x * (1 - ratio)) + (ratio * pB.x),\n            (pA.y * (1 - ratio)) + (ratio * pB.y)\n        );\n    },\n\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function (map, latLngs, ratio) {\n        latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;\n        var n = latLngs.length;\n        if (n < 2) {\n            return null;\n        }\n\n        // ensure the ratio is between 0 and 1;\n        ratio = Math.max(Math.min(ratio, 1), 0);\n\n        if (ratio === 0) {\n            return {\n                latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n                predecessor: -1\n            };\n        }\n        if (ratio == 1) {\n            return {\n                latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),\n                predecessor: latLngs.length - 2\n            };\n        }\n\n        // project the LatLngs as Points,\n        // and compute total planar length of the line at max precision\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var pts = [];\n        var lineLength = 0;\n        for(var i = 0; i < n; i++) {\n            pts[i] = map.project(latLngs[i], maxzoom);\n            if(i > 0)\n              lineLength += pts[i-1].distanceTo(pts[i]);\n        }\n\n        var ratioDist = lineLength * ratio;\n\n\t\t// follow the line segments [ab], adding lengths,\n        // until we find the segment where the points should lie on\n\t\tvar cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;\n\t\tfor (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n\t\t\tvar pointA = pts[i], pointB = pts[i+1];\n\n\t\t\tcumulativeDistanceToA = cumulativeDistanceToB;\n\t\t\tcumulativeDistanceToB += pointA.distanceTo(pointB);\n\t\t}\n\t\t\n\t\tif (pointA == undefined && pointB == undefined) { // Happens when line has no length\n\t\t\tvar pointA = pts[0], pointB = pts[1], i = 1;\n\t\t}\n\n\t\t// compute the ratio relative to the segment [ab]\n\t\tvar segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;\n\t\tvar interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n\t\treturn {\n\t\t\tlatLng: map.unproject(interpolatedPoint, maxzoom),\n\t\t\tpredecessor: i-1\n\t\t};\n    },\n\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function (map, polyline, latlng) {\n        var latlngs = polyline.getLatLngs();\n        if (latlng.equals(latlngs[0]))\n            return 0.0;\n        if (latlng.equals(latlngs[latlngs.length-1]))\n            return 1.0;\n\n        var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n            lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n            total_length = lengths[lengths.length-1],\n            portion = 0,\n            found = false;\n        for (var i=0, n = latlngs.length-1; i < n; i++) {\n            var l1 = latlngs[i],\n                l2 = latlngs[i+1];\n            portion = lengths[i];\n            if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n                portion += l1.distanceTo(point);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n        }\n        return portion / total_length;\n    },\n\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function (polyline) {\n        return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function (map, polyline, start, end) {\n        if (start > end) {\n            return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);\n        }\n\n        // Bound start and end to [0-1]\n        start = Math.max(Math.min(start, 1), 0);\n        end = Math.max(Math.min(end, 1), 0);\n\n        var latlngs = polyline.getLatLngs(),\n            startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n            endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        // Return single point if start == end\n        if (start == end) {\n            var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n            return [point.latLng];\n        }\n        // Array.slice() works indexes at 0\n        if (startpoint.predecessor == -1)\n            startpoint.predecessor = 0;\n        if (endpoint.predecessor == -1)\n            endpoint.predecessor = 0;\n        var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);\n        result.unshift(startpoint.latLng);\n        result.push(endpoint.latLng);\n        return result;\n    },\n\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[lla.length-1]).equals(llb[0]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[0]).equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs(),\n            start = lla[0];\n        return start.equals(llb[0]) || start.equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function(a, b) {\n        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n    },\n\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function(a, b) {\n        var s = (b.y - a.y) / (b.x - a.x),\n            o = a.y - (s * a.x);\n        return {'a': s, 'b': o};\n    },\n\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var angleRad = angleDeg*Math.PI/180,\n            pPoint = map.project(latlngPoint, maxzoom),\n            pCenter = map.project(latlngCenter, maxzoom),\n            x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,\n            y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;\n        return map.unproject(new L.Point(x2,y2), maxzoom);\n    },\n\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function(latlng1, latlng2) {\n        var rad = Math.PI / 180,\n            lat1 = latlng1.lat * rad,\n            lat2 = latlng2.lat * rad,\n            lon1 = latlng1.lng * rad,\n            lon2 = latlng2.lng * rad,\n            y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n            x = Math.cos(lat1) * Math.sin(lat2) -\n                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n        var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n        return bearing >= 180 ? bearing-360 : bearing;\n    },\n\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function(latlng, heading, distance) {\n        heading = (heading + 360) % 360;\n        var rad = Math.PI / 180,\n            radInv = 180 / Math.PI,\n            R = L.CRS.Earth.R, // approximation of Earth's radius\n            lon1 = latlng.lng * rad,\n            lat1 = latlng.lat * rad,\n            rheading = heading * rad,\n            sinLat1 = Math.sin(lat1),\n            cosLat1 = Math.cos(lat1),\n            cosDistR = Math.cos(distance / R),\n            sinDistR = Math.sin(distance / R),\n            lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n                sinDistR * Math.cos(rheading)),\n            lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n                cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n        lon2 = lon2 * radInv;\n        lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n        return L.latLng([lat2 * radInv, lon2]);\n    },\n\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function(map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n          pointB = map.latLngToContainerPoint(latlngB),\n          angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function(map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n          latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    },\n});\n\nreturn L.GeometryUtil;\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}