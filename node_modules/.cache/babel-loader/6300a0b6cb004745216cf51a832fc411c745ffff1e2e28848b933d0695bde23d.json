{"ast":null,"code":"function modulus(i, n) {\n  return (i % n + n) % n;\n}\nfunction definedProps(obj) {\n  return Object.fromEntries(Object.entries(obj).filter(_ref => {\n    let [k, v] = _ref;\n    return v !== undefined;\n  }));\n}\n\n/**\n * Whether or not a string is in the format '<number>m'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInMeters(value) {\n  return value.toString().trim().slice(value.toString().length - 1, value.toString().length) === 'm';\n}\n\n/**\n * Whether or not a string is in the format '<number>%'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInPercent(value) {\n  return value.toString().trim().slice(value.toString().length - 1, value.toString().length) === '%';\n}\n\n/**\n * Whether or not a string is in the format '<number>px'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInPixels(value) {\n  return value.toString().trim().slice(value.toString().length - 2, value.toString().length) === 'px';\n}\nfunction pixelsToMeters(pixels, map) {\n  let refPoint1 = map.getCenter();\n  let xy1 = map.latLngToLayerPoint(refPoint1);\n  let xy2 = {\n    x: xy1.x + Number(pixels),\n    y: xy1.y\n  };\n  let refPoint2 = map.layerPointToLatLng(xy2);\n  let derivedMeters = map.distance(refPoint1, refPoint2);\n  return derivedMeters;\n}\nL.Polyline.include({\n  /**\n   * Adds arrowheads to an L.polyline\n   * @param {object} options The options for the arrowhead.  See documentation for details\n   * @returns The L.polyline instance that they arrowheads are attached to\n   */\n  arrowheads: function () {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Merge user input options with default options:\n    const defaults = {\n      yawn: 60,\n      size: '15%',\n      frequency: 'allvertices',\n      proportionalToTotal: false\n    };\n    this.options.noClip = true;\n    let actualOptions = Object.assign({}, defaults, options);\n    this._arrowheadOptions = actualOptions;\n    this._hatsApplied = true;\n    return this;\n  },\n  buildVectorHats: function (options) {\n    var _this = this;\n    // Reset variables from previous this._update()\n    if (this._arrowheads) {\n      this._arrowheads.remove();\n    }\n    if (this._ghosts) {\n      this._ghosts.remove();\n    }\n\n    //  -------------------------------------------------------- //\n    //  ------------  FILTER THE OPTIONS ----------------------- //\n    /*\n     * The next 3 lines folds the options of the parent polyline into the default options for all polylines\n     * The options for the arrowhead are then folded in as well\n     * All options defined in parent polyline will be inherited by the arrowhead, unless otherwise specified in the arrowhead(options) call\n     */\n\n    let defaultOptionsOfParent = Object.getPrototypeOf(Object.getPrototypeOf(this.options));\n\n    // merge default options of parent polyline (this.options's prototype's prototype) with options passed to parent polyline (this.options).\n    let parentOptions = Object.assign({}, defaultOptionsOfParent, this.options);\n\n    // now merge in the options the user has put in the arrowhead call\n    let hatOptions = Object.assign({}, parentOptions, options);\n\n    // ...with a few exceptions:\n    hatOptions.smoothFactor = 1;\n    hatOptions.fillOpacity = 1;\n    hatOptions.fill = options.fill ? true : false;\n    hatOptions.interactive = false;\n\n    //  ------------  FILTER THE OPTIONS END -------------------- //\n    //  --------------------------------------------------------- //\n\n    //  --------------------------------------------------------- //\n    //  ------ LOOP THROUGH EACH POLYLINE SEGMENT --------------- //\n    //  ------ TO CALCULATE HAT SIZES AND CAPTURE IN ARRAY ------ //\n\n    let size = options.size.toString(); // stringify if its a number\n    let allhats = []; // empty array to receive hat polylines\n    const {\n      frequency,\n      offsets\n    } = options;\n    if (offsets?.start || offsets?.end) {\n      this._buildGhosts({\n        start: offsets.start,\n        end: offsets.end\n      });\n    }\n    const lineToTrace = this._ghosts || this;\n    lineToTrace._parts.forEach((peice, index) => {\n      // Immutable variables for each peice\n      const latlngs = peice.map(point => this._map.layerPointToLatLng(point));\n      const totalLength = (() => {\n        let total = 0;\n        for (var i = 0; i < peice.length - 1; i++) {\n          total += this._map.distance(latlngs[i], latlngs[i + 1]);\n        }\n        return total;\n      })();\n\n      // TBD by options if tree below\n      let derivedLatLngs;\n      let derivedBearings;\n      let spacing;\n      let noOfPoints;\n\n      //  Determining latlng and bearing arrays based on frequency choice:\n      if (!isNaN(frequency)) {\n        spacing = 1 / frequency;\n        noOfPoints = frequency;\n      } else if (isInPercent(frequency)) {\n        console.error('Error: arrowhead frequency option cannot be given in percent.  Try another unit.');\n      } else if (isInMeters(frequency)) {\n        spacing = frequency.slice(0, frequency.length - 1) / totalLength;\n        noOfPoints = 1 / spacing;\n        // round things out for more even spacing:\n        noOfPoints = Math.floor(noOfPoints);\n        spacing = 1 / noOfPoints;\n      } else if (isInPixels(frequency)) {\n        spacing = (() => {\n          let chosenFrequency = frequency.slice(0, frequency.length - 2);\n          let derivedMeters = pixelsToMeters(chosenFrequency, this._map);\n          return derivedMeters / totalLength;\n        })();\n        noOfPoints = 1 / spacing;\n\n        // round things out for more even spacing:\n        noOfPoints = Math.floor(noOfPoints);\n        spacing = 1 / noOfPoints;\n      }\n      if (options.frequency === 'allvertices') {\n        derivedBearings = (() => {\n          let bearings = [];\n          for (var i = 1; i < latlngs.length; i++) {\n            let bearing = L.GeometryUtil.angle(this._map, latlngs[modulus(i - 1, latlngs.length)], latlngs[i]) + 180;\n            bearings.push(bearing);\n          }\n          return bearings;\n        })();\n        derivedLatLngs = latlngs;\n        derivedLatLngs.shift();\n      } else if (options.frequency === 'endonly' && latlngs.length >= 2) {\n        derivedLatLngs = [latlngs[latlngs.length - 1]];\n        derivedBearings = [L.GeometryUtil.angle(this._map, latlngs[latlngs.length - 2], latlngs[latlngs.length - 1]) + 180];\n      } else {\n        derivedLatLngs = [];\n        let interpolatedPoints = [];\n        for (var i = 0; i < noOfPoints; i++) {\n          let interpolatedPoint = L.GeometryUtil.interpolateOnLine(this._map, latlngs, spacing * (i + 1));\n          if (interpolatedPoint) {\n            interpolatedPoints.push(interpolatedPoint);\n            derivedLatLngs.push(interpolatedPoint.latLng);\n          }\n        }\n        derivedBearings = (() => {\n          let bearings = [];\n          for (var i = 0; i < interpolatedPoints.length; i++) {\n            let bearing = L.GeometryUtil.angle(this._map, latlngs[interpolatedPoints[i].predecessor + 1], latlngs[interpolatedPoints[i].predecessor]);\n            bearings.push(bearing);\n          }\n          return bearings;\n        })();\n      }\n      let hats = [];\n\n      // Function to build hats based on index and a given hatsize in meters\n      const pushHats = function (size) {\n        let localHatOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let yawn = localHatOptions.yawn ?? options.yawn;\n        let leftWingPoint = L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] - yawn / 2, size);\n        let rightWingPoint = L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] + yawn / 2, size);\n        let hatPoints = [[leftWingPoint.lat, leftWingPoint.lng], [derivedLatLngs[i].lat, derivedLatLngs[i].lng], [rightWingPoint.lat, rightWingPoint.lng]];\n        let hat = options.fill ? L.polygon(hatPoints, {\n          ...hatOptions,\n          ...localHatOptions\n        }) : L.polyline(hatPoints, {\n          ...hatOptions,\n          ...localHatOptions\n        });\n        hats.push(hat);\n      }; // pushHats()\n\n      // Function to build hats based on pixel input\n      const pushHatsFromPixels = function (size) {\n        let localHatOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let sizePixels = size.slice(0, size.length - 2);\n        let yawn = localHatOptions.yawn ?? options.yawn;\n        let derivedXY = _this._map.latLngToLayerPoint(derivedLatLngs[i]);\n        let bearing = derivedBearings[i];\n        let thetaLeft = (180 - bearing - yawn / 2) * (Math.PI / 180),\n          thetaRight = (180 - bearing + yawn / 2) * (Math.PI / 180);\n        let dxLeft = sizePixels * Math.sin(thetaLeft),\n          dyLeft = sizePixels * Math.cos(thetaLeft),\n          dxRight = sizePixels * Math.sin(thetaRight),\n          dyRight = sizePixels * Math.cos(thetaRight);\n        let leftWingXY = {\n          x: derivedXY.x + dxLeft,\n          y: derivedXY.y + dyLeft\n        };\n        let rightWingXY = {\n          x: derivedXY.x + dxRight,\n          y: derivedXY.y + dyRight\n        };\n        let leftWingPoint = _this._map.layerPointToLatLng(leftWingXY),\n          rightWingPoint = _this._map.layerPointToLatLng(rightWingXY);\n        let hatPoints = [[leftWingPoint.lat, leftWingPoint.lng], [derivedLatLngs[i].lat, derivedLatLngs[i].lng], [rightWingPoint.lat, rightWingPoint.lng]];\n        let hat = options.fill ? L.polygon(hatPoints, {\n          ...hatOptions,\n          ...localHatOptions\n        }) : L.polyline(hatPoints, {\n          ...hatOptions,\n          ...localHatOptions\n        });\n        hats.push(hat);\n      }; // pushHatsFromPixels()\n\n      //  -------  LOOP THROUGH POINTS IN EACH SEGMENT ---------- //\n      for (var i = 0; i < derivedLatLngs.length; i++) {\n        let {\n          perArrowheadOptions,\n          ...globalOptions\n        } = options;\n        perArrowheadOptions = perArrowheadOptions ? perArrowheadOptions(i) : {};\n        perArrowheadOptions = Object.assign(globalOptions, definedProps(perArrowheadOptions));\n        size = perArrowheadOptions.size ?? size;\n\n        // ---- If size is chosen in meters -------------------------\n        if (isInMeters(size)) {\n          let hatSize = size.slice(0, size.length - 1);\n          pushHats(hatSize, perArrowheadOptions);\n\n          // ---- If size is chosen in percent ------------------------\n        } else if (isInPercent(size)) {\n          let sizePercent = size.slice(0, size.length - 1);\n          let hatSize = (() => {\n            if (options.frequency === 'endonly' && options.proportionalToTotal) {\n              return totalLength * sizePercent / 100;\n            } else {\n              let averageDistance = totalLength / (peice.length - 1);\n              return averageDistance * sizePercent / 100;\n            }\n          })(); // hatsize calculation\n\n          pushHats(hatSize, perArrowheadOptions);\n\n          // ---- If size is chosen in pixels --------------------------\n        } else if (isInPixels(size)) {\n          pushHatsFromPixels(options.size, perArrowheadOptions);\n\n          // ---- If size unit is not given -----------------------------\n        } else {\n          console.error('Error: Arrowhead size unit not defined.  Check your arrowhead options.');\n        } // if else block for Size\n      } // for loop for each point witin a peice\n\n      allhats.push(...hats);\n    }); // forEach peice\n\n    //  --------- LOOP THROUGH EACH POLYLINE END ---------------- //\n    //  --------------------------------------------------------- //\n\n    let arrowheads = L.layerGroup(allhats);\n    this._arrowheads = arrowheads;\n    return this;\n  },\n  getArrowheads: function () {\n    if (this._arrowheads) {\n      return this._arrowheads;\n    } else {\n      return console.error(`Error: You tried to call '.getArrowheads() on a shape that does not have a arrowhead.  Use '.arrowheads()' to add a arrowheads before trying to call '.getArrowheads()'`);\n    }\n  },\n  /**\n   * Builds ghost polylines that are clipped versions of the polylines based on the offsets\n   * If offsets are used, arrowheads are drawn from 'this._ghosts' rather than 'this'\n   */\n  _buildGhosts: function (_ref2) {\n    let {\n      start,\n      end\n    } = _ref2;\n    if (start || end) {\n      let latlngs = this.getLatLngs();\n      latlngs = Array.isArray(latlngs[0]) ? latlngs : [latlngs];\n      const newLatLngs = latlngs.map(segment => {\n        // Get total distance of original latlngs\n        const totalLength = (() => {\n          let total = 0;\n          for (var i = 0; i < segment.length - 1; i++) {\n            total += this._map.distance(segment[i], segment[i + 1]);\n          }\n          return total;\n        })();\n\n        // Modify latlngs to end at interpolated point\n        if (start) {\n          let endOffsetInMeters = (() => {\n            if (isInMeters(start)) {\n              return Number(start.slice(0, start.length - 1));\n            } else if (isInPixels(start)) {\n              let pixels = Number(start.slice(0, start.length - 2));\n              return pixelsToMeters(pixels, this._map);\n            }\n          })();\n          let newStart = L.GeometryUtil.interpolateOnLine(this._map, segment, endOffsetInMeters / totalLength);\n          segment = segment.slice(newStart.predecessor === -1 ? 1 : newStart.predecessor + 1, segment.length);\n          segment.unshift(newStart.latLng);\n        }\n        if (end) {\n          let endOffsetInMeters = (() => {\n            if (isInMeters(end)) {\n              return Number(end.slice(0, end.length - 1));\n            } else if (isInPixels(end)) {\n              let pixels = Number(end.slice(0, end.length - 2));\n              return pixelsToMeters(pixels, this._map);\n            }\n          })();\n          let newEnd = L.GeometryUtil.interpolateOnLine(this._map, segment, (totalLength - endOffsetInMeters) / totalLength);\n          segment = segment.slice(0, newEnd.predecessor + 1);\n          segment.push(newEnd.latLng);\n        }\n        return segment;\n      });\n      this._ghosts = L.polyline(newLatLngs, {\n        ...this.options,\n        color: 'rgba(0,0,0,0)',\n        stroke: 0,\n        smoothFactor: 0,\n        interactive: false\n      });\n      this._ghosts.addTo(this._map);\n    }\n  },\n  deleteArrowheads: function () {\n    if (this._arrowheads) {\n      this._arrowheads.remove();\n      delete this._arrowheads;\n      delete this._arrowheadOptions;\n      this._hatsApplied = false;\n    }\n    if (this._ghosts) {\n      this._ghosts.remove();\n    }\n  },\n  _update: function () {\n    if (!this._map) {\n      return;\n    }\n    this._clipPoints();\n    this._simplifyPoints();\n    this._updatePath();\n    if (this._hatsApplied) {\n      this.buildVectorHats(this._arrowheadOptions);\n      this._map.addLayer(this._arrowheads);\n    }\n  },\n  remove: function () {\n    if (this._arrowheads) {\n      this._arrowheads.remove();\n    }\n    if (this._ghosts) {\n      this._ghosts.remove();\n    }\n    return this.removeFrom(this._map || this._mapToAdd);\n  }\n});\nL.LayerGroup.include({\n  removeLayer: function (layer) {\n    var id = layer in this._layers ? layer : this.getLayerId(layer);\n    if (this._map && this._layers[id]) {\n      if (this._layers[id]._arrowheads) {\n        this._layers[id]._arrowheads.remove();\n      }\n      this._map.removeLayer(this._layers[id]);\n    }\n    delete this._layers[id];\n    return this;\n  },\n  onRemove: function (map, layer) {\n    for (var layer in this._layers) {\n      if (this._layers[layer]) {\n        this._layers[layer].remove();\n      }\n    }\n    this.eachLayer(map.removeLayer, map);\n  }\n});\nL.Map.include({\n  removeLayer: function (layer) {\n    var id = L.Util.stamp(layer);\n    if (layer._arrowheads) {\n      layer._arrowheads.remove();\n    }\n    if (layer._ghosts) {\n      layer._ghosts.remove();\n    }\n    if (!this._layers[id]) {\n      return this;\n    }\n    if (this._loaded) {\n      layer.onRemove(this);\n    }\n    if (layer.getAttribution && this.attributionControl) {\n      this.attributionControl.removeAttribution(layer.getAttribution());\n    }\n    delete this._layers[id];\n    if (this._loaded) {\n      this.fire('layerremove', {\n        layer: layer\n      });\n      layer.fire('remove');\n    }\n    layer._map = layer._mapToAdd = null;\n    return this;\n  }\n});\nL.GeoJSON.include({\n  geometryToLayer: function (geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n      coords = geometry ? geometry.coordinates : null,\n      layers = [],\n      pointToLayer = options && options.pointToLayer,\n      _coordsToLatLng = options && options.coordsToLatLng || L.GeoJSON.coordsToLatLng,\n      latlng,\n      latlngs,\n      i,\n      len;\n    if (!coords && !geometry) {\n      return null;\n    }\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return this._pointToLayer(pointToLayer, geojson, latlng, options);\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(this._pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n        return new L.FeatureGroup(layers);\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = L.GeoJSON.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        var polyline = new L.Polyline(latlngs, options);\n        if (options.arrowheads) {\n          polyline.arrowheads(options.arrowheads);\n        }\n        return polyline;\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = L.GeoJSON.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new L.Polygon(latlngs, options);\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var layer = this.geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n          if (layer) {\n            layers.push(layer);\n          }\n        }\n        return new L.FeatureGroup(layers);\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  },\n  addData: function (geojson) {\n    var features = L.Util.isArray(geojson) ? geojson : geojson.features,\n      i,\n      len,\n      feature;\n    if (features) {\n      for (i = 0, len = features.length; i < len; i++) {\n        // only add this if geometry or geometries are set and not null\n        feature = features[i];\n        if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n          this.addData(feature);\n        }\n      }\n      return this;\n    }\n    var options = this.options;\n    if (options.filter && !options.filter(geojson)) {\n      return this;\n    }\n    var layer = this.geometryToLayer(geojson, options);\n    if (!layer) {\n      return this;\n    }\n    layer.feature = L.GeoJSON.asFeature(geojson);\n    layer.defaultOptions = layer.options;\n    this.resetStyle(layer);\n    if (options.onEachFeature) {\n      options.onEachFeature(geojson, layer);\n    }\n    return this.addLayer(layer);\n  },\n  _pointToLayer: function (pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new L.Marker(latlng, options && options.markersInheritOptions && options);\n  }\n});","map":{"version":3,"names":["modulus","i","n","definedProps","obj","Object","fromEntries","entries","filter","_ref","k","v","undefined","isInMeters","value","toString","trim","slice","length","isInPercent","isInPixels","pixelsToMeters","pixels","map","refPoint1","getCenter","xy1","latLngToLayerPoint","xy2","x","Number","y","refPoint2","layerPointToLatLng","derivedMeters","distance","L","Polyline","include","arrowheads","options","arguments","defaults","yawn","size","frequency","proportionalToTotal","noClip","actualOptions","assign","_arrowheadOptions","_hatsApplied","buildVectorHats","_this","_arrowheads","remove","_ghosts","defaultOptionsOfParent","getPrototypeOf","parentOptions","hatOptions","smoothFactor","fillOpacity","fill","interactive","allhats","offsets","start","end","_buildGhosts","lineToTrace","_parts","forEach","peice","index","latlngs","point","_map","totalLength","total","derivedLatLngs","derivedBearings","spacing","noOfPoints","isNaN","console","error","Math","floor","chosenFrequency","bearings","bearing","GeometryUtil","angle","push","shift","interpolatedPoints","interpolatedPoint","interpolateOnLine","latLng","predecessor","hats","pushHats","localHatOptions","leftWingPoint","destination","rightWingPoint","hatPoints","lat","lng","hat","polygon","polyline","pushHatsFromPixels","sizePixels","derivedXY","thetaLeft","PI","thetaRight","dxLeft","sin","dyLeft","cos","dxRight","dyRight","leftWingXY","rightWingXY","perArrowheadOptions","globalOptions","hatSize","sizePercent","averageDistance","layerGroup","getArrowheads","_ref2","getLatLngs","Array","isArray","newLatLngs","segment","endOffsetInMeters","newStart","unshift","newEnd","color","stroke","addTo","deleteArrowheads","_update","_clipPoints","_simplifyPoints","_updatePath","addLayer","removeFrom","_mapToAdd","LayerGroup","removeLayer","layer","id","_layers","getLayerId","onRemove","eachLayer","Map","Util","stamp","_loaded","getAttribution","attributionControl","removeAttribution","fire","GeoJSON","geometryToLayer","geojson","geometry","type","coords","coordinates","layers","pointToLayer","_coordsToLatLng","coordsToLatLng","latlng","len","_pointToLayer","FeatureGroup","coordsToLatLngs","Polygon","geometries","properties","Error","addData","features","feature","asFeature","defaultOptions","resetStyle","onEachFeature","pointToLayerFn","Marker","markersInheritOptions"],"sources":["C:/vscode/logistik-company/node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js"],"sourcesContent":["function modulus(i, n) {\n\treturn ((i % n) + n) % n;\n}\n\nfunction definedProps(obj) {\n\treturn Object.fromEntries(\n\t\tObject.entries(obj).filter(([k, v]) => v !== undefined)\n\t);\n}\n\n/**\n * Whether or not a string is in the format '<number>m'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInMeters(value) {\n\treturn (\n\t\tvalue\n\t\t\t.toString()\n\t\t\t.trim()\n\t\t\t.slice(value.toString().length - 1, value.toString().length) === 'm'\n\t);\n}\n\n/**\n * Whether or not a string is in the format '<number>%'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInPercent(value) {\n\treturn (\n\t\tvalue\n\t\t\t.toString()\n\t\t\t.trim()\n\t\t\t.slice(value.toString().length - 1, value.toString().length) === '%'\n\t);\n}\n\n/**\n * Whether or not a string is in the format '<number>px'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInPixels(value) {\n\treturn (\n\t\tvalue\n\t\t\t.toString()\n\t\t\t.trim()\n\t\t\t.slice(value.toString().length - 2, value.toString().length) === 'px'\n\t);\n}\n\nfunction pixelsToMeters(pixels, map) {\n\tlet refPoint1 = map.getCenter();\n\tlet xy1 = map.latLngToLayerPoint(refPoint1);\n\tlet xy2 = {\n\t\tx: xy1.x + Number(pixels),\n\t\ty: xy1.y,\n\t};\n\tlet refPoint2 = map.layerPointToLatLng(xy2);\n\tlet derivedMeters = map.distance(refPoint1, refPoint2);\n\treturn derivedMeters;\n}\n\nL.Polyline.include({\n\t/**\n\t * Adds arrowheads to an L.polyline\n\t * @param {object} options The options for the arrowhead.  See documentation for details\n\t * @returns The L.polyline instance that they arrowheads are attached to\n\t */\n\tarrowheads: function (options = {}) {\n\t\t// Merge user input options with default options:\n\t\tconst defaults = {\n\t\t\tyawn: 60,\n\t\t\tsize: '15%',\n\t\t\tfrequency: 'allvertices',\n\t\t\tproportionalToTotal: false,\n\t\t};\n\n\t\tthis.options.noClip = true;\n\n\t\tlet actualOptions = Object.assign({}, defaults, options);\n\t\tthis._arrowheadOptions = actualOptions;\n\n\t\tthis._hatsApplied = true;\n\t\treturn this;\n\t},\n\n\tbuildVectorHats: function (options) {\n\t\t// Reset variables from previous this._update()\n\t\tif (this._arrowheads) {\n\t\t\tthis._arrowheads.remove();\n\t\t}\n\n\t\tif (this._ghosts) {\n\t\t\tthis._ghosts.remove();\n\t\t}\n\n\t\t//  -------------------------------------------------------- //\n\t\t//  ------------  FILTER THE OPTIONS ----------------------- //\n\t\t/*\n\t\t * The next 3 lines folds the options of the parent polyline into the default options for all polylines\n\t\t * The options for the arrowhead are then folded in as well\n\t\t * All options defined in parent polyline will be inherited by the arrowhead, unless otherwise specified in the arrowhead(options) call\n\t\t */\n\n\t\tlet defaultOptionsOfParent = Object.getPrototypeOf(\n\t\t\tObject.getPrototypeOf(this.options)\n\t\t);\n\n\t\t// merge default options of parent polyline (this.options's prototype's prototype) with options passed to parent polyline (this.options).\n\t\tlet parentOptions = Object.assign({}, defaultOptionsOfParent, this.options);\n\n\t\t// now merge in the options the user has put in the arrowhead call\n\t\tlet hatOptions = Object.assign({}, parentOptions, options);\n\n\t\t// ...with a few exceptions:\n\t\thatOptions.smoothFactor = 1;\n\t\thatOptions.fillOpacity = 1;\n\t\thatOptions.fill = options.fill ? true : false;\n\t\thatOptions.interactive = false;\n\n\t\t//  ------------  FILTER THE OPTIONS END -------------------- //\n\t\t//  --------------------------------------------------------- //\n\n\t\t//  --------------------------------------------------------- //\n\t\t//  ------ LOOP THROUGH EACH POLYLINE SEGMENT --------------- //\n\t\t//  ------ TO CALCULATE HAT SIZES AND CAPTURE IN ARRAY ------ //\n\n\t\tlet size = options.size.toString(); // stringify if its a number\n\t\tlet allhats = []; // empty array to receive hat polylines\n\t\tconst { frequency, offsets } = options;\n\n\t\tif (offsets?.start || offsets?.end) {\n\t\t\tthis._buildGhosts({ start: offsets.start, end: offsets.end });\n\t\t}\n\n\t\tconst lineToTrace = this._ghosts || this;\n\n\t\tlineToTrace._parts.forEach((peice, index) => {\n\t\t\t// Immutable variables for each peice\n\t\t\tconst latlngs = peice.map((point) => this._map.layerPointToLatLng(point));\n\n\t\t\tconst totalLength = (() => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (var i = 0; i < peice.length - 1; i++) {\n\t\t\t\t\ttotal += this._map.distance(latlngs[i], latlngs[i + 1]);\n\t\t\t\t}\n\t\t\t\treturn total;\n\t\t\t})();\n\n\t\t\t// TBD by options if tree below\n\t\t\tlet derivedLatLngs;\n\t\t\tlet derivedBearings;\n\t\t\tlet spacing;\n\t\t\tlet noOfPoints;\n\n\t\t\t//  Determining latlng and bearing arrays based on frequency choice:\n\t\t\tif (!isNaN(frequency)) {\n\t\t\t\tspacing = 1 / frequency;\n\t\t\t\tnoOfPoints = frequency;\n\t\t\t} else if (isInPercent(frequency)) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Error: arrowhead frequency option cannot be given in percent.  Try another unit.'\n\t\t\t\t);\n\t\t\t} else if (isInMeters(frequency)) {\n\t\t\t\tspacing = frequency.slice(0, frequency.length - 1) / totalLength;\n\t\t\t\tnoOfPoints = 1 / spacing;\n\t\t\t\t// round things out for more even spacing:\n\t\t\t\tnoOfPoints = Math.floor(noOfPoints);\n\t\t\t\tspacing = 1 / noOfPoints;\n\t\t\t} else if (isInPixels(frequency)) {\n\t\t\t\tspacing = (() => {\n\t\t\t\t\tlet chosenFrequency = frequency.slice(0, frequency.length - 2);\n\t\t\t\t\tlet derivedMeters = pixelsToMeters(chosenFrequency, this._map);\n\t\t\t\t\treturn derivedMeters / totalLength;\n\t\t\t\t})();\n\n\t\t\t\tnoOfPoints = 1 / spacing;\n\n\t\t\t\t// round things out for more even spacing:\n\t\t\t\tnoOfPoints = Math.floor(noOfPoints);\n\t\t\t\tspacing = 1 / noOfPoints;\n\t\t\t}\n\n\t\t\tif (options.frequency === 'allvertices') {\n\t\t\t\tderivedBearings = (() => {\n\t\t\t\t\tlet bearings = [];\n\t\t\t\t\tfor (var i = 1; i < latlngs.length; i++) {\n\t\t\t\t\t\tlet bearing =\n\t\t\t\t\t\t\tL.GeometryUtil.angle(\n\t\t\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\t\t\tlatlngs[modulus(i - 1, latlngs.length)],\n\t\t\t\t\t\t\t\tlatlngs[i]\n\t\t\t\t\t\t\t) + 180;\n\t\t\t\t\t\tbearings.push(bearing);\n\t\t\t\t\t}\n\t\t\t\t\treturn bearings;\n\t\t\t\t})();\n\n\t\t\t\tderivedLatLngs = latlngs;\n\t\t\t\tderivedLatLngs.shift();\n\t\t\t} else if (options.frequency === 'endonly' && latlngs.length >= 2) {\n\t\t\t\tderivedLatLngs = [latlngs[latlngs.length - 1]];\n\n\t\t\t\tderivedBearings = [\n\t\t\t\t\tL.GeometryUtil.angle(\n\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\tlatlngs[latlngs.length - 2],\n\t\t\t\t\t\tlatlngs[latlngs.length - 1]\n\t\t\t\t\t) + 180,\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tderivedLatLngs = [];\n\t\t\t\tlet interpolatedPoints = [];\n\t\t\t\tfor (var i = 0; i < noOfPoints; i++) {\n\t\t\t\t\tlet interpolatedPoint = L.GeometryUtil.interpolateOnLine(\n\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\tlatlngs,\n\t\t\t\t\t\tspacing * (i + 1)\n\t\t\t\t\t);\n\n\t\t\t\t\tif (interpolatedPoint) {\n\t\t\t\t\t\tinterpolatedPoints.push(interpolatedPoint);\n\t\t\t\t\t\tderivedLatLngs.push(interpolatedPoint.latLng);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tderivedBearings = (() => {\n\t\t\t\t\tlet bearings = [];\n\n\t\t\t\t\tfor (var i = 0; i < interpolatedPoints.length; i++) {\n\t\t\t\t\t\tlet bearing = L.GeometryUtil.angle(\n\t\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\t\tlatlngs[interpolatedPoints[i].predecessor + 1],\n\t\t\t\t\t\t\tlatlngs[interpolatedPoints[i].predecessor]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbearings.push(bearing);\n\t\t\t\t\t}\n\t\t\t\t\treturn bearings;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\tlet hats = [];\n\n\t\t\t// Function to build hats based on index and a given hatsize in meters\n\t\t\tconst pushHats = (size, localHatOptions = {}) => {\n\t\t\t\tlet yawn = localHatOptions.yawn ?? options.yawn;\n\n\t\t\t\tlet leftWingPoint = L.GeometryUtil.destination(\n\t\t\t\t\tderivedLatLngs[i],\n\t\t\t\t\tderivedBearings[i] - yawn / 2,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t\tlet rightWingPoint = L.GeometryUtil.destination(\n\t\t\t\t\tderivedLatLngs[i],\n\t\t\t\t\tderivedBearings[i] + yawn / 2,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t\tlet hatPoints = [\n\t\t\t\t\t[leftWingPoint.lat, leftWingPoint.lng],\n\t\t\t\t\t[derivedLatLngs[i].lat, derivedLatLngs[i].lng],\n\t\t\t\t\t[rightWingPoint.lat, rightWingPoint.lng],\n\t\t\t\t];\n\n\t\t\t\tlet hat = options.fill\n\t\t\t\t\t? L.polygon(hatPoints, { ...hatOptions, ...localHatOptions })\n\t\t\t\t\t: L.polyline(hatPoints, { ...hatOptions, ...localHatOptions });\n\n\t\t\t\thats.push(hat);\n\t\t\t}; // pushHats()\n\n\t\t\t// Function to build hats based on pixel input\n\t\t\tconst pushHatsFromPixels = (size, localHatOptions = {}) => {\n\t\t\t\tlet sizePixels = size.slice(0, size.length - 2);\n\t\t\t\tlet yawn = localHatOptions.yawn ?? options.yawn;\n\n\t\t\t\tlet derivedXY = this._map.latLngToLayerPoint(derivedLatLngs[i]);\n\n\t\t\t\tlet bearing = derivedBearings[i];\n\n\t\t\t\tlet thetaLeft = (180 - bearing - yawn / 2) * (Math.PI / 180),\n\t\t\t\t\tthetaRight = (180 - bearing + yawn / 2) * (Math.PI / 180);\n\n\t\t\t\tlet dxLeft = sizePixels * Math.sin(thetaLeft),\n\t\t\t\t\tdyLeft = sizePixels * Math.cos(thetaLeft),\n\t\t\t\t\tdxRight = sizePixels * Math.sin(thetaRight),\n\t\t\t\t\tdyRight = sizePixels * Math.cos(thetaRight);\n\n\t\t\t\tlet leftWingXY = {\n\t\t\t\t\tx: derivedXY.x + dxLeft,\n\t\t\t\t\ty: derivedXY.y + dyLeft,\n\t\t\t\t};\n\t\t\t\tlet rightWingXY = {\n\t\t\t\t\tx: derivedXY.x + dxRight,\n\t\t\t\t\ty: derivedXY.y + dyRight,\n\t\t\t\t};\n\n\t\t\t\tlet leftWingPoint = this._map.layerPointToLatLng(leftWingXY),\n\t\t\t\t\trightWingPoint = this._map.layerPointToLatLng(rightWingXY);\n\n\t\t\t\tlet hatPoints = [\n\t\t\t\t\t[leftWingPoint.lat, leftWingPoint.lng],\n\t\t\t\t\t[derivedLatLngs[i].lat, derivedLatLngs[i].lng],\n\t\t\t\t\t[rightWingPoint.lat, rightWingPoint.lng],\n\t\t\t\t];\n\n\t\t\t\tlet hat = options.fill\n\t\t\t\t\t? L.polygon(hatPoints, { ...hatOptions, ...localHatOptions })\n\t\t\t\t\t: L.polyline(hatPoints, { ...hatOptions, ...localHatOptions });\n\n\t\t\t\thats.push(hat);\n\t\t\t}; // pushHatsFromPixels()\n\n\t\t\t//  -------  LOOP THROUGH POINTS IN EACH SEGMENT ---------- //\n\t\t\tfor (var i = 0; i < derivedLatLngs.length; i++) {\n\t\t\t\tlet { perArrowheadOptions, ...globalOptions } = options;\n\n\t\t\t\tperArrowheadOptions = perArrowheadOptions ? perArrowheadOptions(i) : {};\n\t\t\t\tperArrowheadOptions = Object.assign(\n\t\t\t\t\tglobalOptions,\n\t\t\t\t\tdefinedProps(perArrowheadOptions)\n\t\t\t\t);\n\n\t\t\t\tsize = perArrowheadOptions.size ?? size;\n\n\t\t\t\t// ---- If size is chosen in meters -------------------------\n\t\t\t\tif (isInMeters(size)) {\n\t\t\t\t\tlet hatSize = size.slice(0, size.length - 1);\n\t\t\t\t\tpushHats(hatSize, perArrowheadOptions);\n\n\t\t\t\t\t// ---- If size is chosen in percent ------------------------\n\t\t\t\t} else if (isInPercent(size)) {\n\t\t\t\t\tlet sizePercent = size.slice(0, size.length - 1);\n\t\t\t\t\tlet hatSize = (() => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\toptions.frequency === 'endonly' &&\n\t\t\t\t\t\t\toptions.proportionalToTotal\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn (totalLength * sizePercent) / 100;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet averageDistance = totalLength / (peice.length - 1);\n\t\t\t\t\t\t\treturn (averageDistance * sizePercent) / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t})(); // hatsize calculation\n\n\t\t\t\t\tpushHats(hatSize, perArrowheadOptions);\n\n\t\t\t\t\t// ---- If size is chosen in pixels --------------------------\n\t\t\t\t} else if (isInPixels(size)) {\n\t\t\t\t\tpushHatsFromPixels(options.size, perArrowheadOptions);\n\n\t\t\t\t\t// ---- If size unit is not given -----------------------------\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Error: Arrowhead size unit not defined.  Check your arrowhead options.'\n\t\t\t\t\t);\n\t\t\t\t} // if else block for Size\n\t\t\t} // for loop for each point witin a peice\n\n\t\t\tallhats.push(...hats);\n\t\t}); // forEach peice\n\n\t\t//  --------- LOOP THROUGH EACH POLYLINE END ---------------- //\n\t\t//  --------------------------------------------------------- //\n\n\t\tlet arrowheads = L.layerGroup(allhats);\n\t\tthis._arrowheads = arrowheads;\n\n\t\treturn this;\n\t},\n\n\tgetArrowheads: function () {\n\t\tif (this._arrowheads) {\n\t\t\treturn this._arrowheads;\n\t\t} else {\n\t\t\treturn console.error(\n\t\t\t\t`Error: You tried to call '.getArrowheads() on a shape that does not have a arrowhead.  Use '.arrowheads()' to add a arrowheads before trying to call '.getArrowheads()'`\n\t\t\t);\n\t\t}\n\t},\n\n\t/**\n\t * Builds ghost polylines that are clipped versions of the polylines based on the offsets\n\t * If offsets are used, arrowheads are drawn from 'this._ghosts' rather than 'this'\n\t */\n\t_buildGhosts: function ({ start, end }) {\n\t\tif (start || end) {\n\t\t\tlet latlngs = this.getLatLngs();\n\n\t\t\tlatlngs = Array.isArray(latlngs[0]) ? latlngs : [latlngs];\n\n\t\t\tconst newLatLngs = latlngs.map((segment) => {\n\t\t\t\t// Get total distance of original latlngs\n\t\t\t\tconst totalLength = (() => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tfor (var i = 0; i < segment.length - 1; i++) {\n\t\t\t\t\t\ttotal += this._map.distance(segment[i], segment[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t})();\n\n\t\t\t\t// Modify latlngs to end at interpolated point\n\t\t\t\tif (start) {\n\t\t\t\t\tlet endOffsetInMeters = (() => {\n\t\t\t\t\t\tif (isInMeters(start)) {\n\t\t\t\t\t\t\treturn Number(start.slice(0, start.length - 1));\n\t\t\t\t\t\t} else if (isInPixels(start)) {\n\t\t\t\t\t\t\tlet pixels = Number(start.slice(0, start.length - 2));\n\t\t\t\t\t\t\treturn pixelsToMeters(pixels, this._map);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\n\t\t\t\t\tlet newStart = L.GeometryUtil.interpolateOnLine(\n\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\tsegment,\n\t\t\t\t\t\tendOffsetInMeters / totalLength\n\t\t\t\t\t);\n\n\t\t\t\t\tsegment = segment.slice(\n\t\t\t\t\t\tnewStart.predecessor === -1 ? 1 : newStart.predecessor + 1,\n\t\t\t\t\t\tsegment.length\n\t\t\t\t\t);\n\t\t\t\t\tsegment.unshift(newStart.latLng);\n\t\t\t\t}\n\n\t\t\t\tif (end) {\n\t\t\t\t\tlet endOffsetInMeters = (() => {\n\t\t\t\t\t\tif (isInMeters(end)) {\n\t\t\t\t\t\t\treturn Number(end.slice(0, end.length - 1));\n\t\t\t\t\t\t} else if (isInPixels(end)) {\n\t\t\t\t\t\t\tlet pixels = Number(end.slice(0, end.length - 2));\n\t\t\t\t\t\t\treturn pixelsToMeters(pixels, this._map);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\n\t\t\t\t\tlet newEnd = L.GeometryUtil.interpolateOnLine(\n\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\tsegment,\n\t\t\t\t\t\t(totalLength - endOffsetInMeters) / totalLength\n\t\t\t\t\t);\n\n\t\t\t\t\tsegment = segment.slice(0, newEnd.predecessor + 1);\n\t\t\t\t\tsegment.push(newEnd.latLng);\n\t\t\t\t}\n\n\t\t\t\treturn segment;\n\t\t\t});\n\n\t\t\tthis._ghosts = L.polyline(newLatLngs, {\n\t\t\t\t...this.options,\n\t\t\t\tcolor: 'rgba(0,0,0,0)',\n\t\t\t\tstroke: 0,\n\t\t\t\tsmoothFactor: 0,\n\t\t\t\tinteractive: false,\n\t\t\t});\n\t\t\tthis._ghosts.addTo(this._map);\n\t\t}\n\t},\n\n\tdeleteArrowheads: function () {\n\t\tif (this._arrowheads) {\n\t\t\tthis._arrowheads.remove();\n\t\t\tdelete this._arrowheads;\n\t\t\tdelete this._arrowheadOptions;\n\t\t\tthis._hatsApplied = false;\n\t\t}\n\t\tif (this._ghosts) {\n\t\t\tthis._ghosts.remove();\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tif (!this._map) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clipPoints();\n\t\tthis._simplifyPoints();\n\t\tthis._updatePath();\n\n\t\tif (this._hatsApplied) {\n\t\t\tthis.buildVectorHats(this._arrowheadOptions);\n\t\t\tthis._map.addLayer(this._arrowheads);\n\t\t}\n\t},\n\n\tremove: function () {\n\t\tif (this._arrowheads) {\n\t\t\tthis._arrowheads.remove();\n\t\t}\n\t\tif (this._ghosts) {\n\t\t\tthis._ghosts.remove();\n\t\t}\n\t\treturn this.removeFrom(this._map || this._mapToAdd);\n\t},\n});\n\nL.LayerGroup.include({\n\tremoveLayer: function (layer) {\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\n\n\t\tif (this._map && this._layers[id]) {\n\t\t\tif (this._layers[id]._arrowheads) {\n\t\t\t\tthis._layers[id]._arrowheads.remove();\n\t\t\t}\n\t\t\tthis._map.removeLayer(this._layers[id]);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\treturn this;\n\t},\n\n\tonRemove: function (map, layer) {\n\t\tfor (var layer in this._layers) {\n\t\t\tif (this._layers[layer]) {\n\t\t\t\tthis._layers[layer].remove();\n\t\t\t}\n\t\t}\n\n\t\tthis.eachLayer(map.removeLayer, map);\n\t},\n});\n\nL.Map.include({\n\tremoveLayer: function (layer) {\n\t\tvar id = L.Util.stamp(layer);\n\n\t\tif (layer._arrowheads) {\n\t\t\tlayer._arrowheads.remove();\n\t\t}\n\t\tif (layer._ghosts) {\n\t\t\tlayer._ghosts.remove();\n\t\t}\n\n\t\tif (!this._layers[id]) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this._loaded) {\n\t\t\tlayer.onRemove(this);\n\t\t}\n\n\t\tif (layer.getAttribution && this.attributionControl) {\n\t\t\tthis.attributionControl.removeAttribution(layer.getAttribution());\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\tif (this._loaded) {\n\t\t\tthis.fire('layerremove', { layer: layer });\n\t\t\tlayer.fire('remove');\n\t\t}\n\n\t\tlayer._map = layer._mapToAdd = null;\n\n\t\treturn this;\n\t},\n});\n\nL.GeoJSON.include({\n\tgeometryToLayer: function (geojson, options) {\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n\t\t\tcoords = geometry ? geometry.coordinates : null,\n\t\t\tlayers = [],\n\t\t\tpointToLayer = options && options.pointToLayer,\n\t\t\t_coordsToLatLng =\n\t\t\t\t(options && options.coordsToLatLng) || L.GeoJSON.coordsToLatLng,\n\t\t\tlatlng,\n\t\t\tlatlngs,\n\t\t\ti,\n\t\t\tlen;\n\n\t\tif (!coords && !geometry) {\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch (geometry.type) {\n\t\t\tcase 'Point':\n\t\t\t\tlatlng = _coordsToLatLng(coords);\n\t\t\t\treturn this._pointToLayer(pointToLayer, geojson, latlng, options);\n\n\t\t\tcase 'MultiPoint':\n\t\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\n\t\t\t\t\tlatlng = _coordsToLatLng(coords[i]);\n\t\t\t\t\tlayers.push(\n\t\t\t\t\t\tthis._pointToLayer(pointToLayer, geojson, latlng, options)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn new L.FeatureGroup(layers);\n\n\t\t\tcase 'LineString':\n\t\t\tcase 'MultiLineString':\n\t\t\t\tlatlngs = L.GeoJSON.coordsToLatLngs(\n\t\t\t\t\tcoords,\n\t\t\t\t\tgeometry.type === 'LineString' ? 0 : 1,\n\t\t\t\t\t_coordsToLatLng\n\t\t\t\t);\n\t\t\t\tvar polyline = new L.Polyline(latlngs, options);\n\t\t\t\tif (options.arrowheads) {\n\t\t\t\t\tpolyline.arrowheads(options.arrowheads);\n\t\t\t\t}\n\t\t\t\treturn polyline;\n\n\t\t\tcase 'Polygon':\n\t\t\tcase 'MultiPolygon':\n\t\t\t\tlatlngs = L.GeoJSON.coordsToLatLngs(\n\t\t\t\t\tcoords,\n\t\t\t\t\tgeometry.type === 'Polygon' ? 1 : 2,\n\t\t\t\t\t_coordsToLatLng\n\t\t\t\t);\n\t\t\t\treturn new L.Polygon(latlngs, options);\n\n\t\t\tcase 'GeometryCollection':\n\t\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\n\t\t\t\t\tvar layer = this.geometryToLayer(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeometry: geometry.geometries[i],\n\t\t\t\t\t\t\ttype: 'Feature',\n\t\t\t\t\t\t\tproperties: geojson.properties,\n\t\t\t\t\t\t},\n\t\t\t\t\t\toptions\n\t\t\t\t\t);\n\n\t\t\t\t\tif (layer) {\n\t\t\t\t\t\tlayers.push(layer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn new L.FeatureGroup(layers);\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\n\t\t}\n\t},\n\n\taddData: function (geojson) {\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\n\t\t\ti,\n\t\t\tlen,\n\t\t\tfeature;\n\n\t\tif (features) {\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\n\t\t\t\t// only add this if geometry or geometries are set and not null\n\t\t\t\tfeature = features[i];\n\t\t\t\tif (\n\t\t\t\t\tfeature.geometries ||\n\t\t\t\t\tfeature.geometry ||\n\t\t\t\t\tfeature.features ||\n\t\t\t\t\tfeature.coordinates\n\t\t\t\t) {\n\t\t\t\t\tthis.addData(feature);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\tif (options.filter && !options.filter(geojson)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tvar layer = this.geometryToLayer(geojson, options);\n\t\tif (!layer) {\n\t\t\treturn this;\n\t\t}\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\n\n\t\tlayer.defaultOptions = layer.options;\n\t\tthis.resetStyle(layer);\n\n\t\tif (options.onEachFeature) {\n\t\t\toptions.onEachFeature(geojson, layer);\n\t\t}\n\n\t\treturn this.addLayer(layer);\n\t},\n\n\t_pointToLayer: function (pointToLayerFn, geojson, latlng, options) {\n\t\treturn pointToLayerFn\n\t\t\t? pointToLayerFn(geojson, latlng)\n\t\t\t: new L.Marker(\n\t\t\t\t\tlatlng,\n\t\t\t\t\toptions && options.markersInheritOptions && options\n\t\t\t  );\n\t},\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}